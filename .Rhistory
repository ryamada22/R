# 閉曲面オブジェクトを作る
xxx <- my.spherical.harm.mesh(A = A., B = B, n = n.mesh)
#xxx$v <- xxx$v + rnorm(length(xxx$v))*r
g <- graph.edgelist(xxx$edge,directed=FALSE)
vname <- paste("",1:length(V(g)),sep="")
g <- set_vertex_attr(g,"name",value=vname)
# edge lengths
w <- sqrt(apply((xxx$v[xxx$edge[,1],]-xxx$v[xxx$edge[,2],])^2,1,sum))
# thetas,phis
tmp <- my_sphere_tri_mesh(n.mesh)
xyz <- tmp$xyz
tosp <- TOSPHERE(xyz[, 1], xyz[, 2], xyz[, 3])
tp <- cbind(tosp[[1]]/360 * 2 * pi, tosp[[2]]/360 * 2 * pi)
return(list(X = xxx$v,X.sp=xyz, E = xxx$edge, tri=xxx$f, angles = cbind(tp[,2],tp[,1]),g=g,w=w ))
}
my.cell.shape3 <- function(A,B,N){
# 形の凹凸・複雑さをコントロールするパラメタ、n,k
n <- length(A[,1])
#k <- 8
# メッシュのノード数をコントロールするパラメタ
n.mesh <- N # 色々試すなら、32くらいにしておくのが無難。送ったhtmlファイルはn.mesh=64
# 形を球面調和関数係数ベクトルで指定する
#A. <- matrix(runif(n^2), n, n)
#A.[1, 1] <- k
A. <- A
#B <- matrix(rnorm(n^2), n, n)
# 閉曲面オブジェクトを作る
xxx <- my.spherical.harm.mesh(A = A., B = B, n = n.mesh)
#xxx$v <- xxx$v + rnorm(length(xxx$v))*r
g <- graph.edgelist(xxx$edge,directed=FALSE)
vname <- paste("",1:length(V(g)),sep="")
g <- set_vertex_attr(g,"name",value=vname)
# edge lengths
w <- sqrt(apply((xxx$v[xxx$edge[,1],]-xxx$v[xxx$edge[,2],])^2,1,sum))
# thetas,phis
tmp <- my_sphere_tri_mesh(n.mesh)
xyz <- tmp$xyz
tosp <- TOSPHERE(xyz[, 1], xyz[, 2], xyz[, 3])
tp <- cbind(tosp[[1]]/360 * 2 * pi, tosp[[2]]/360 * 2 * pi)
return(list(X = xxx$v,X.sp=xyz, E = xxx$edge, tri=xxx$f, angles = cbind(tp[,2],tp[,1]),g=g,w=w ))
}
my.plot.shape <- function(shape,add=FALSE){
if(add){
points3d(shape$X)
}else{
plot3d(shape$X)
}
segments3d(shape$X[c(t(shape$E)), ])
}
# 還り値
## X : 3D 座標
## X.sp : 球面上の座標
## E : エッジ
## tri : 三角形頂点トリオ
## angles : 球面上の角座標
## g,w : グラフオブジェクトとエッジの重み
my.3Dobj <- function(d=6,k=5,N=15){
shape1 <- my.cell.shape2(d,k,N)
# 3D 座標
X <- shape1$X
# その球面上座標(このままであと、均等になってしまっている)
Xsp <- shape1$X.sp
# 球面上の点配置を少しずらす
Rot <- Random.Start(3)
Mat <- diag(rep(1,3))
Mat <- Mat + rnorm(9)*0.3
Xsp[,1] <- Xsp[,1]+0.4
Xsp <- Xsp %*% Mat
Xsp <- Xsp/sqrt(apply(Xsp^2,1,sum))
shape1$X.sp <- Xsp
return(shape1)
}
my.3Dobj2 <- function(A,B,N=15){
shape1 <- my.cell.shape3(A,B,N)
# 3D 座標
X <- shape1$X
# その球面上座標(このままであと、均等になってしまっている)
Xsp <- shape1$X.sp
# 球面上の点配置を少しずらす
Rot <- Random.Start(3)
Mat <- diag(rep(1,3))
Mat <- Mat + rnorm(9)*0.3
Xsp[,1] <- Xsp[,1]+0.4
Xsp <- Xsp %*% Mat
Xsp <- Xsp/sqrt(apply(Xsp^2,1,sum))
shape1$X.sp <- Xsp
return(shape1)
}
# triは各行に3頂点座標v1,v2,v3が入っており
# v1,v2,v3の支配領域を返すこととする
my.part.tri <- function(tri){
L1 <- sqrt(sum((tri[1,]-tri[2,])^2))
L2 <- sqrt(sum((tri[2,]-tri[3,])^2))
L3 <- sqrt(sum((tri[3,]-tri[1,])^2))
L <- c(L1,L2,L3)
# 外接円半径
R <- prod(L)/(sqrt(sum(L))*sqrt(sum(L)-2*L[1])*sqrt(sum(L)-2*L[2])*sqrt(sum(L)-2*L[3]))
h1 <- sqrt(R^2-(1/2*L1)^2)
h2 <- sqrt(R^2-(1/2*L2)^2)
h3 <- sqrt(R^2-(1/2*L3)^2)
a1 <- 1/2 * 1/2*L1*h1 + 1/2*1/2*L3*h3
a2 <- 1/2 * 1/2*L1*h1 + 1/2*1/2*L2*h2
a3 <- 1/2 * 1/2*L2*h2 + 1/2*1/2*L3*h3
return(c(a1,a2,a3))
}
# tris: 三角形の３頂点IDの行列
# x : verticesの3次元頂点座標
# st : TRUEなら割合に、FALSEなら実面積値を返す
my.vertex.area <- function(tris,x,st=TRUE){
as <- matrix(0,length(tris[,1]),3)
for(i in 1:length(as[,1])){
tmptris <- x[tris[i,],]
as[i,] <- my.part.tri(tmptris)
}
ret <- rep(0,length(x[,1]))
for(i in 1:length(ret)){
ret[i] <- sum(as[which(tris==i)])
}
if(st){
ret <- ret/sum(ret)
}
return(ret)
}
# g はグラフオブジェクト
# w はエッジの長さ
# tri は三角形の頂点ＩＤの３列行列
# x は頂点の座標
# 返り値のdは、頂点間距離行列
# aは頂点の支配領域面積
my.pr.v <- function(g,w,tris,x){
a <- my.vertex.area(tris,x)
d <- distances(g,weights=w)
return(list(d=d,a=a))
}
# d1,d2は頂点間距離
# a1,a2は、頂点の支配面積
# sはガウシアカーネルの標準偏差
my.IP.weighted <- function(d1,a1,d2,a2,s=1){
ret <- 0
tmp <- outer(d1,d2,"-")
tmp2 <- outer(a1,a2,"*")
ret <- sum(pnorm(tmp,0,s) * tmp2)
return(ret)
}
# dは頂点間グラフ距離
# aは頂点の支配領域面積
# xは確率質量を求めたい、「距離相当値」
# sはガウシアンカーネル密度推定の標準偏差
my.hist <- function(d,a,x,s=1){
ret <- rep(0,length(x))
for(i in 1:length(x)){
ret[i] <- sum(a * dnorm(d-x[i],0,s))
}
return(ret/sum(ret))
}
# d1,d2は頂点間距離
# a1,a2は、頂点の支配面積
# s2はガウシアカーネルの標準偏差
my.IP.obj <- function(d1,a1,d2,a2,s2){
ret <- 0
dd12 <- (d1) %*% t(d2)
theta12 <- 1/2 * log(dd12)
theta11 <- 1/2*log(apply(d1^2,1,sum))
theta22 <- 1/2*log(apply(d2^2,1,sum))
dsq <- theta11+theta22 - 2 * theta12
d <- sqrt(dsq)
ret <- sum(dnorm(d,0,s2) * outer(a1,a2,"*"))
return(ret)
}
# da1,da2は２つの閉曲面のdANDaとする
# s1はmy.IP.weightedのためのガウシアンカーネル用標準偏差
# s2は２つの閉曲面の関数内積のためのガウシアンカーネル用標準偏差
my.IP.obj2 <- function(d1,a1,d2,a2,s1,s2){
n1 <- length(a1)
n2 <- length(a2)
A1s <- apply(d1^2,1,sum)
A2s <- apply(d2^2,1,sum)
A12 <- d1 %*% t(d2)
A12. <- t(t(-2*A12 + A1s) + A2s)
tmp <- 1/sqrt(2*pi*s2^2) * exp(-A12./(2*s2^2))
tmp.aa <- tmp * outer(a1,a2,"*")
ret <- sum(tmp.aa)
#for(i in 1:n1){
#  A1 <- 1/2*log(A1s[i])
#  for(j in 1:n2){
#    A2 <- 1/2*log(A2s[j])
#    tmp <- 1/2*log(A12[i,j])
#    lensq <- (A1+A2-2*tmp)
#    ret <- ret + 1/(n1*n2)*1/sqrt(2*pi*s2^2)*exp(-lensq/(2*s2^2))
#  }
#}
return(ret)
}
n.obj0 <- 10
nn <- 8
A0 <- matrix(0,nn,nn)
A0[1,1] <- 5
B0 <- matrix(0,nn,nn)
cnt <- 1
scl <- 3
param <- c(6,2)
Objs <- list()
for(i in 1:n.obj0){
#Objs[[i]] <- my.3Dobj(d=ds[i],k=ks[i],N=15)
A <- A0
A[param[1],param[2]] <- i * 1/n.obj0 * scl
B <- B0
Objs[[cnt]] <- my.3Dobj2(A,B,N=15)
cnt <- cnt+1
}
param <- c(4,3)
for(i in 1:n.obj0){
#Objs[[i]] <- my.3Dobj(d=ds[i],k=ks[i],N=15)
A <- A0
A[param[1],param[2]] <- i * 1/n.obj0 * scl
B <- B0
Objs[[cnt]] <- my.3Dobj2(A,B,N=15)
cnt <- cnt+1
}
n.obj <- length(Objs)
dANDa <- list()
for(i in 1:n.obj){
dANDa[[i]] <- my.pr.v(Objs[[i]]$g,Objs[[i]]$w,Objs[[i]]$tri,Objs[[i]]$X)
}
tmp <- matrix(0,n.obj,2)
for(i in 1:n.obj){
tmp[i,] <- range(dANDa[[i]]$d)
}
d.range <- range(tmp)
s1 <- 1
# ガウシアンカーネルのsdの３倍の余裕を前後に持たせる
d.range. <- c(d.range[1]-3*s1,d.range[2]+3*s1)
# グリッド数
Nval <- 100
d.value <- seq(from=d.range.[1],to=d.range.[2],length=Nval)
# オブジェクトごとに、距離分布を算出する
h.list <- list()
for(i in 1:n.obj){
h.list[[i]] <- matrix(0,length(dANDa[[i]]$a),Nval)
for(j in 1:length(h.list[[i]][,1])){
h.list[[i]][j,] <- my.hist(dANDa[[i]]$d[j,],dANDa[[i]]$a,d.value,s1)
}
}
#matplot(t(h.list[[1]]),type="l")
h.mean <- matrix(0,n.obj,Nval)
for(i in 1:n.obj){
h.mean[i,] <- apply(h.list[[i]] * dANDa[[i]]$a,2,sum)
}
IPmean <- h.mean %*% t(h.mean)
eigenout <- eigen(log(IPmean))
plot(eigenout[[1]])
pairs(eigenout[[2]][,1:4])
ord <- order(eigenout[[2]][,1])
plot(ord)
rg <- range(eigenout[[2]][,1:3])
rgdif <- rg[2]-rg[1]
plot3d(eigenout[[2]][,1:3])
text3d(eigenout[[2]][,1:3],texts=paste("",1:n.obj))
#for(i in 1:n.obj){
#tmpobj <- Objs[[i]]
#tmpobj$X <- tmpobj$X*rgdif/n.obj * 0.8
#tobeadded <- eigenout[[2]][i,1:3] + sign(i %% 2 -0.5)*rnorm(3)*rgdif*0.02
#tmpobj$X <- t(t(tmpobj$X) + tobeadded)
#my.plot.shape(tmpobj,add=TRUE)
#}
ax <- 1:3
plot3d(eigenout[[2]][,ax])
spheres3d(eigenout[[2]][,ax],radius=0.03,color=rep(1:3,each=n.obj0))
text3d(eigenout[[2]][,ax]+0.05,texts=paste("",1:n.obj))
rg <- range(eigenout[[2]][,1:3])
rgdif <- rg[2]-rg[1]
plot3d(eigenout[[2]][,1:3])
#text3d(eigenout[[2]][,1:3],texts=paste("",1:n.obj))
for(i in 1:n.obj){
tmpobj <- Objs[[i]]
tmpobj$X <- tmpobj$X*rgdif/n.obj * 0.8
tobeadded <- eigenout[[2]][i,1:3] + sign(i %% 2 -0.5)*rnorm(3)*rgdif*0.02
tmpobj$X <- t(t(tmpobj$X) + tobeadded)
my.plot.shape(tmpobj,add=TRUE)
}
param <- c(6,2)
Objs <- list()
for(i in 1:n.obj0){
#Objs[[i]] <- my.3Dobj(d=ds[i],k=ks[i],N=15)
A <- A0
A[param[1],param[2]] <- i * 1/n.obj0 * scl
B <- B0
Objs[[cnt]] <- my.3Dobj2(A,B,N=15)
cnt <- cnt+1
}
param <- c(4,3)
for(i in 1:n.obj0){
#Objs[[i]] <- my.3Dobj(d=ds[i],k=ks[i],N=15)
A <- A0
A[param[1],param[2]] <- i * 1/n.obj0 * scl
B <- B0
Objs[[cnt]] <- my.3Dobj2(A,B,N=15)
cnt <- cnt+1
}
for(i in 1:n.obj0){
Objs[[cnt]] <- Objs[[i]]
Objs[[cnt]]$X[,1] <- Objs[[cnt]]$X[,1]*2
cnt <- cnt+1
}
for(i in 1:n.obj0){
Objs[[cnt]] <- list()
Objs[[cnt]] <- Objs[[i]]
Objs[[cnt]]$X[,1] <- Objs[[cnt]]$X[,1]*2
cnt <- cnt+1
}
cnt
n.obj0 <- 10
nn <- 8
A0 <- matrix(0,nn,nn)
A0[1,1] <- 5
B0 <- matrix(0,nn,nn)
cnt <- 1
scl <- 3
param <- c(6,2)
Objs <- list()
for(i in 1:n.obj0){
#Objs[[i]] <- my.3Dobj(d=ds[i],k=ks[i],N=15)
A <- A0
A[param[1],param[2]] <- i * 1/n.obj0 * scl
B <- B0
Objs[[cnt]] <- my.3Dobj2(A,B,N=15)
cnt <- cnt+1
}
param <- c(4,3)
for(i in 1:n.obj0){
#Objs[[i]] <- my.3Dobj(d=ds[i],k=ks[i],N=15)
A <- A0
A[param[1],param[2]] <- i * 1/n.obj0 * scl
B <- B0
Objs[[cnt]] <- my.3Dobj2(A,B,N=15)
cnt <- cnt+1
}
for(i in 1:n.obj0){
#Objs[[cnt]] <- list()
Objs[[cnt]] <- Objs[[i]]
Objs[[cnt]]$X[,1] <- Objs[[cnt]]$X[,1]*2
cnt <- cnt+1
}
n.obj <- length(Objs)
dANDa <- list()
for(i in 1:n.obj){
dANDa[[i]] <- my.pr.v(Objs[[i]]$g,Objs[[i]]$w,Objs[[i]]$tri,Objs[[i]]$X)
}
tmp <- matrix(0,n.obj,2)
for(i in 1:n.obj){
tmp[i,] <- range(dANDa[[i]]$d)
}
d.range <- range(tmp)
s1 <- 1
# ガウシアンカーネルのsdの３倍の余裕を前後に持たせる
d.range. <- c(d.range[1]-3*s1,d.range[2]+3*s1)
# グリッド数
Nval <- 100
d.value <- seq(from=d.range.[1],to=d.range.[2],length=Nval)
# オブジェクトごとに、距離分布を算出する
h.list <- list()
for(i in 1:n.obj){
h.list[[i]] <- matrix(0,length(dANDa[[i]]$a),Nval)
for(j in 1:length(h.list[[i]][,1])){
h.list[[i]][j,] <- my.hist(dANDa[[i]]$d[j,],dANDa[[i]]$a,d.value,s1)
}
}
#matplot(t(h.list[[1]]),type="l")
h.mean <- matrix(0,n.obj,Nval)
for(i in 1:n.obj){
h.mean[i,] <- apply(h.list[[i]] * dANDa[[i]]$a,2,sum)
}
IPmean <- h.mean %*% t(h.mean)
eigenout <- eigen(log(IPmean))
plot(eigenout[[1]])
pairs(eigenout[[2]][,1:4])
ord <- order(eigenout[[2]][,1])
plot(ord)
rg <- range(eigenout[[2]][,1:3])
rgdif <- rg[2]-rg[1]
plot3d(eigenout[[2]][,1:3])
text3d(eigenout[[2]][,1:3],texts=paste("",1:n.obj))
#for(i in 1:n.obj){
#tmpobj <- Objs[[i]]
#tmpobj$X <- tmpobj$X*rgdif/n.obj * 0.8
#tobeadded <- eigenout[[2]][i,1:3] + sign(i %% 2 -0.5)*rnorm(3)*rgdif*0.02
#tmpobj$X <- t(t(tmpobj$X) + tobeadded)
#my.plot.shape(tmpobj,add=TRUE)
#}
rg <- range(eigenout[[2]][,1:3])
rgdif <- rg[2]-rg[1]
plot3d(eigenout[[2]][,1:3])
#text3d(eigenout[[2]][,1:3],texts=paste("",1:n.obj))
for(i in 1:n.obj){
tmpobj <- Objs[[i]]
tmpobj$X <- tmpobj$X*rgdif/n.obj * 0.8
tobeadded <- eigenout[[2]][i,1:3] + sign(i %% 2 -0.5)*rnorm(3)*rgdif*0.02
tmpobj$X <- t(t(tmpobj$X) + tobeadded)
my.plot.shape(tmpobj,add=TRUE)
}
ax <- 1:3
plot3d(eigenout[[2]][,ax])
spheres3d(eigenout[[2]][,ax],radius=0.03,color=rep(1:3,each=n.obj0))
text3d(eigenout[[2]][,ax]+0.05,texts=paste("",1:n.obj))
plot(eigenout[[1]][1:10])
plot(eigenout[[1]][2:10])
n.obj0 <- 10
nn <- 8
A0 <- matrix(0,nn,nn)
A0[1,1] <- 5
B0 <- matrix(0,nn,nn)
cnt <- 1
scl <- 3
param <- c(6,2)
Objs <- list()
for(i in 1:n.obj0){
#Objs[[i]] <- my.3Dobj(d=ds[i],k=ks[i],N=15)
A <- A0
A[param[1],param[2]] <- i * 1/n.obj0 * scl
B <- B0
Objs[[cnt]] <- my.3Dobj2(A,B,N=15)
cnt <- cnt+1
}
param <- c(4,3)
for(i in 1:n.obj0){
#Objs[[i]] <- my.3Dobj(d=ds[i],k=ks[i],N=15)
A <- A0
A[param[1],param[2]] <- i * 1/n.obj0 * scl
B <- B0
Objs[[cnt]] <- my.3Dobj2(A,B,N=15)
cnt <- cnt+1
}
for(i in 1:n.obj0){
#Objs[[cnt]] <- list()
Objs[[cnt]] <- Objs[[i]]
Objs[[cnt]]$X[,1] <- Objs[[cnt]]$X[,1]*2
cnt <- cnt+1
}
for(i in 1:n.obj0){
#Objs[[cnt]] <- list()
Objs[[cnt]] <- Objs[[i+n.obj0]]
Objs[[cnt]]$X[,1] <- Objs[[cnt]]$X[,1]*2
cnt <- cnt+1
}
n.obj <- length(Objs)
dANDa <- list()
for(i in 1:n.obj){
dANDa[[i]] <- my.pr.v(Objs[[i]]$g,Objs[[i]]$w,Objs[[i]]$tri,Objs[[i]]$X)
}
tmp <- matrix(0,n.obj,2)
for(i in 1:n.obj){
tmp[i,] <- range(dANDa[[i]]$d)
}
d.range <- range(tmp)
s1 <- 1
# ガウシアンカーネルのsdの３倍の余裕を前後に持たせる
d.range. <- c(d.range[1]-3*s1,d.range[2]+3*s1)
# グリッド数
Nval <- 100
d.value <- seq(from=d.range.[1],to=d.range.[2],length=Nval)
# オブジェクトごとに、距離分布を算出する
h.list <- list()
for(i in 1:n.obj){
h.list[[i]] <- matrix(0,length(dANDa[[i]]$a),Nval)
for(j in 1:length(h.list[[i]][,1])){
h.list[[i]][j,] <- my.hist(dANDa[[i]]$d[j,],dANDa[[i]]$a,d.value,s1)
}
}
#matplot(t(h.list[[1]]),type="l")
h.mean <- matrix(0,n.obj,Nval)
for(i in 1:n.obj){
h.mean[i,] <- apply(h.list[[i]] * dANDa[[i]]$a,2,sum)
}
IPmean <- h.mean %*% t(h.mean)
eigenout <- eigen(log(IPmean))
plot(eigenout[[1]])
pairs(eigenout[[2]][,1:4])
ord <- order(eigenout[[2]][,1])
plot(ord)
rg <- range(eigenout[[2]][,1:3])
rgdif <- rg[2]-rg[1]
plot3d(eigenout[[2]][,1:3])
text3d(eigenout[[2]][,1:3],texts=paste("",1:n.obj))
#for(i in 1:n.obj){
#tmpobj <- Objs[[i]]
#tmpobj$X <- tmpobj$X*rgdif/n.obj * 0.8
#tobeadded <- eigenout[[2]][i,1:3] + sign(i %% 2 -0.5)*rnorm(3)*rgdif*0.02
#tmpobj$X <- t(t(tmpobj$X) + tobeadded)
#my.plot.shape(tmpobj,add=TRUE)
#}
rg <- range(eigenout[[2]][,1:3])
rgdif <- rg[2]-rg[1]
plot3d(eigenout[[2]][,1:3])
#text3d(eigenout[[2]][,1:3],texts=paste("",1:n.obj))
for(i in 1:n.obj){
tmpobj <- Objs[[i]]
tmpobj$X <- tmpobj$X*rgdif/n.obj * 0.8
tobeadded <- eigenout[[2]][i,1:3] + sign(i %% 2 -0.5)*rnorm(3)*rgdif*0.02
tmpobj$X <- t(t(tmpobj$X) + tobeadded)
my.plot.shape(tmpobj,add=TRUE)
}
ax <- 1:3
plot3d(eigenout[[2]][,ax])
spheres3d(eigenout[[2]][,ax],radius=0.03,color=rep(1:3,each=n.obj0))
text3d(eigenout[[2]][,ax]+0.05,texts=paste("",1:n.obj))
ax <- 1:3
plot3d(eigenout[[2]][,ax])
spheres3d(eigenout[[2]][,ax],radius=0.03,color=rep(1:4,each=n.obj0))
text3d(eigenout[[2]][,ax]+0.05,texts=paste("",1:n.obj))
IIPP <- t(t(-2 * IPmean + diag(IPmean)) + diag(IPmean))
range(IIPP)
image(IIPP)
